A Query Calculus for Spatio-Temporal Object Databases Tony Grifths, Alvaro A.
A.
Fernandes, Nassima Djafri, Norm an W.
Paton Department of Computer Science, University of Manchester Oxford Road, Manchester M13 9PL, United Kingdom fgriffittja.fernandesjndjafrijnormg@cs.man.ac.uk Abstract The development of any comprehensive proposal for spatio-temporal databases involves signicant extension s to many aspects of a non-spatio-temporal architecture.
One  aspect that has received less attention than most is the de-  velopment of a query calculus that can be used to pro-  vide a semantics for spatio-temporal queries and underpin  an effective query optimization and evaluation framework.
 In this paper, we show how a query calculus for spatiotemporal object databases that builds upon the monoid cal-  culus proposed by Fegaras and Maier for ODMG-compliant  database systems can be developed.
The paper shows how an extension of the ODMG type system with spatial and  temporal types can be accommodated into the monoid ap-  proach.
It uses several queries over historical (possibly s patial) data to illustrate how, by mapping them into monoid comprehensions, the way is open for the application of a logical optimizer based on the normalization algorithm pro - posed by Fegaras and Maier.
 1.
Introduction Spatio-temporal databases have been the focus of considerable research activity over a signicant period.
How-  ever, there still exist very few prototypes of complete sys-  tems (see [4] for a mid-1990s survey), and far less prod-  ucts that provide effective support for applications track ing changes to spatial and aspatial data over time.
This is prob-  ably because the design and implementation of a complete  spatio-temporal database is a challenging undertaking, in - volving extensions to all aspects of a non-spatio-temporal  architecture ? data model, query language, query optimizer , query evaluator, programming environment, storage manager, indexes, etc.
The diversity of open issues relating to  such an undertaking has led most researchers to focus on specic aspects of the problem (e.g., indexing, or join algo - rithms), rather than addressing the development of a complete spatio-temporal DBMS.
This has given rise to a sub- stantial collection of results that can be built upon by deve lopers of complete systems, although such an endeavour has  been pursued only rarely.
The Tripod project, from which  this paper emerges, is seeking to design and prototype a  complete spatio-temporal database system that extends the  ODMG standard for object databases [6] with facilities for managing vector spatial data, and for the description of pas t states of both spatial and aspatial data.
ODMG Model Temporal Types Spatial TypesHistories Spatio-Temporal Algebra Spatio-Temporal Calculus Extended OQL Figure 1.
Tripod Components Figure 1 illustrates the relationships between the different components in the Tripod design.
At the core is the  ODMG object model.
The ODMG model is extended in  Tripod with two new categories of primitive type: spatial  types and temporal types.
The spatial types used in Tri-  pod are those of the ROSE algebra [15], which supports the vector types Points,Lines andRegions .
The temporal types supported in Tripod are one-dimensional versions of the ROSE algebra types PointsandLines , and are known as InstantsandTimeIntervals , respectively.
The close relationship between the spatial and the temporal types increases consistency in the representatio n of the different kinds of data.
Past states of all ODMG types, including the spatial and temporal types, can be recorded using histories.
A historyis a set of timestamp-value pairs, where the timestamp is of a temporal type and the value is of any of the types in the extended ODMG model.
Figure 1,  fromHistories inwards represents a spatio-historical object model.
This, however, leaves open the question as to how the resulting model can be queried, and how these queries can  both be given a precise semantics and be effectively optimized.
In this regard, the monoid comprehension calculus  of [8] is extended in Tripod to accommodate the querying of  spatial and temporal data.
In Figure 1, this is illustrated b y the layers representing the query algebraand thequery calculus , the former being derived from the latter using mappings described in [8].
The focus of this paper is on the  query calculus layer in Figure 1.
This layer is important,  in that it provides a semantics for historical queries in object databases, and also because its incorporation within t he monoid comprehension calculus of [8] allows the reuse of the associated query optimization framework, as supported  by the OPTGEN query optimizer generator.
The changes  to the calculus for OQL provided in [8] to support spatial, temporal and historical features are pure extensions (i.e.
, the existing calculus is retained as a subset), and the extensio ns can be used together or separately in queries.
Figure 2 presents an example of a class denition that illustrates the sort of database that can be described using  the model.
The class Cityis itself historical, which means that the duration for which a Cityexists is recorded.
Of the three properties of City, thename attribute is not historical (and thus only the last value assigned to the name is stored), the electionsattribute is not historical but does store values of a temporal type, the attribute wards is collection-valued, the mayorattribute is historical, and the landmass attribute is both historical (so previous as well as current values for the landmass are stored) and of a  spatial type.
For reasons of space, the denition of the clas s Ward is omitted.
historical<TimeIntervals,year> class City  (extent cities)  attribute string name;  attribute <Instants,year> elections;  attribute set<Ward> wards;  historical<TimeIntervals,month> attribute string mayor; historical<TimeIntervals,year> attribute Regions landmass;  Figure 2.
Example Spatio?Historical ODL The remainder of the paper is structured as follows.
Section 2 provides an overview of the structure of Tri-  pod timestamps, snapshots and histories (as well as their  behaviour) by construing them as instances of abstract  data types (ADT).
Section 3 provides an overview of the monoid comprehension approach to query processing in object databases.
Section 4 shows how the constructs in Sec-  tion 2 can be incorporated into the framework described in  Section 3 to give rise to a query calculus for historical obje ct databases.
Section 5 provides examples of use, including  how queries requiring aggregation over historical attribu tes can be expressed.
Section 6 discusses related work.
Section 7 draws some of the conclusions stemming from the  contributions of the paper.
 2.
A Historical Object Model: Construction, Structure and Behaviour Tripod supports the storage, management and querying of entities that change over time through the notion of a history .
A history models the changes that an entity (or its attributes, or the relationships it participates in) under goes as the result of assignments made to it.
In the Tripod ob-  ject model, a request for a history to be maintained can be  made for any construct to which a value can be assigned, i.e., a history is a history of changes in value and it records  episodes of change by identifying these with a timestamp.
 Such timestamps are instances of set-based temporal types  for which a rich collection of predicates and operations is  available.
This section provides an overview of the structu re of Tripod timestamps, snapshots and histories (as well as  their behaviour) by construing them as instances of ADTs.
 The overview focuses on what is needed for the development of the notion of histories as monoids introduced in  Section 4 that opens the way for the denition of the query  calculus contributed by the paper.
For reasons of space,  complete formal descriptions of the Tripod constructs re-  ferred to cannot be given here but have been made available elsewhere [10, 11].
 2.1.
Timestamps as Instances of Temporal Types Tripod extends the set of ODMG primitive types with two temporal types, called InstantsandTimeIntervals, over which a number of operations and predicates (i.e.,  Boolean-valued operations) are dened.
The underlying domain of interpretation is a structure which we refer to  as a temporal realm because it is dened to be a onedimensional specialization of the two-dimensional (spati al) realms dened by G ?uting and Schneider [15].
Roughly, a  temporal realm is a nite set of integers (whereas a spatial realm is a nite integer grid).
Reasons why we adopt this  viewpoint and terminology include: Realm values are set-based, which we nd more suit-  able than individual ones for the kind of set-at-a-time  strategies that are prevalent in query processing archi-  tectures.
 Realm operations are well-dened and have a rich set  of predicates and constructors with nice closure prop-  erties.
Tripod is a spatio-temporal database system and we  nd it useful (for users, developers and researchers) to have realms as a unifying notion for the interpretation  of operations on spatialandtemporal values.
This unication at the level of interpretations propagates upwards in the sense that the predicates and op-  eration on realms are dened once and used (possibly  after renaming) over both spatial and temporal values.
 This also facilitates the reuse of implemented software components, such as those which the authors devel-  oped and described in [18].
In a temporal realm, we may think of a time-point as an integer.
Then, an Instantsvalue is a set of time-points and a TimeIntervalsvalue is a set of pairs of time-points where the rst element is the start, and the second the end, of a contiguous, closed time-interval.
A timestampis either an Instantsvalue or aTimeIntervalsvalue.
Figure 3 illustrates timestamps in graphical form.
In Figure 3, time stamp Ais a TimeIntervalsvalue, and timestamps Band C are Instantsvalues.
Bhappens to be a singleton.
B C A 19 9 1 15 11 22 26 Figure 3.
Example Tripod Timestamps Let denote the set of all timestamps.
Given 2 , some representative predicates and operations dened on are shown in Figure 4.
The operation names should give readers an intuitive understanding of their meaning  based on operations on sets of integers (and integer pairs)  and on classical denitions for temporal predicates (such  as Allen's [2]).
For full details, see the formal seman-  tics in [11] (which, for the reasons alluded to above, fol-  lows [15] closely).
=:  ! boolean after :  ! boolean
ommon points:  ! boolean interse
tion :  !  minus :  !  Figure 4.
Example Operations on Timestamps  Although timestamps can be used by application designers to complement related primitive types in the ODMG standard (e.g., Interval, orTime ), their main purpose is to allow histories to be constructed and operated upon,  as described below.
This requires the introduction of two  other primitive types, called InstantandTimeInterval .
Their values are not timestamps, instead they can be thought of as the building blocks for timestamps.
Consistently with this view, the operations dened on Instant and TimeInterval (and their inverses) are shown in Figure 5.
assemble : 2  ! Instants assemble  : 2  ! TimeIntervals disassemble  : Instants !2  disassemble  : TimeIntervals !2  Figure 5.
Conversions over Temporal Values 2.2.
Snapshots as Values from the Object Model As mentioned above, a request for a history to be maintained can be made for any construct to which a value can  be assigned.
Each such value is a snapshotof the construct at the times denoted by the associated timestamp.
As a con-  sequence of the possible value assignments that are dened  in the ODMG object model, a history can be kept in the Tripod object model for all of object identiers, attribute  values, and relationship instances.
Thus, a history asso-  ciates timestamps and snapshots drawn from the domain of  (one among) object identiers (if the history is of an ob-  ject), attribute values (whose type can be any valid Tripod, and hence ODMG, type) or relationship instances (of any  ODMG-supported cardinality).
 2.3.
The Structure of Histories Ahistory is a quadruple =h      i, wheredenotes the domain of values whose changes records,is either InstantsorTimeIntervals,is the granularity of , andis a set of pairs, called states, of the formh   i, where is a Tripod timestamp andis a snapshot.
In the rest of the paper, let denote, as before, the set of all timestamps; , the set of all snapshots;, the set of all states; and , the set of all histories.
In a history, a set of states is constrained to be an injective function from the set  of all timestamps occurring in to the set of all snapshots occurring in, i.e., for any history ,  : 2  ! 2 .
Therefore, the following invariants hold, for any history  =h      i: 1.
Every timestamp occurring in is of type 2 f Instants ,TimeIntervals gand has granularity.
 2.
For every snapshotoccurring in,2 .
3.
A particular timestamp is associated with at most one snapshot, i.e., a history does not record different values  as valid at the same time.
4.
A particular snapshot is associated with at most one timestamp, i.e., if a value is assigned more than once,  in the corresponding history the new occurrence causes  the timestamp of the previous occurrence to adjust ap-  propriately (in other words, coalescing takes place by  default, and, if so, explicit mention of earlier values may not be maintained).
For example,  =hint TimeIntervals year f h [1981 1986? 22 i h [1989 1991? 24 ig i is a history of integer snapshots (say, a property like salary) timestamped with time-intervals whose elements denote years.
Thus, from year 1981to year 1986, the salary was 22, and from year 1989to year 1991, the salary was 24.
2.4.
The Behaviour of Histories This subsection provides an overview of the operations available in Tripod to operate on histories construed as instances of an ADT, which leads to their behaviour be-  ing categorized into constructor (not discussed in this pa-  per), query, merge and update operations.
The overview is quite focussed.
Full details are available elsewhere [10].
 Note that, if needed, we distinguish operations dened  on histories from operations dened on timestamps by underliningthe latter.
2.4.1 Query Operations on Histories  Representative query operations on histories are shown in  Figure 6.
Note that the rst expression in Figure 6 is  in fact a template for a set of signatures parameterized on any element of the set of predicates on timestamps.
 For example, given that beforeis a member of that set, letting  = beforein the template yields the following signature ContainsTimestam pbefore:  ! boolean .
Other such parameterized templates include FilterByTimesta mp.
ContainsTimestamp:   ! boolean FilterBySnapshot :  !  Figure 6.
Querying Histories Given boolean =ftrue false g, ContainsTimesta mp(   ) = trueif 9  2 (  ) ^ (   ), otherwise ContainsTimestam p(   )= false.
For example, if the state sets of two histories  and both with =int,= TimeIntervalsand identical , are  = fh[1  6?12 i h[9  11? 14 ig and = fh[5  10?13 i h[13 20?15 igthen ContainsTimestam pbefore(  [9  10?) =trueand ContainsTimestam pafter(  [21 22?) =false.
In contrast to ContainsTimestam pwhich queries a history for a true/false reply, FilterBySnapshot exemplies operations that query histories for a re-  ply that is itself a history.
Given  =h      i and  = h       i,FilterBySnapshot (   ) =   where = fh  ij  () = g.
For example, if  andare as above, then FilterBySnapshot (  12) =   = h      fh[1  6? 12 igi andFilterBySnapshot (  12) =   = h       fgi .
2.4.2 Merge and Update Operations on Histories  Representative merge and update operations on histories ar e shown in Figure 7.
 :  !  DeleteTimestamp : !  InsertState : !  Figure 7.
Merging and Updating Histories Given   = h       iand  = h       i,  (     ) =  = h       i, where  = (    j(  (   ) n  (   )) [  1 .
In other words, taking the union of two histories is equiv-  alent to taking the union of their state sets but choosing the state in the second argument whenever there is a state  in the rst argument with the same timestamp but differ-  ent snapshot.
This is to satisfy the invariants that char-  acterize histories.
For example, using inx notation, if  the state sets of two histories  andare as exemplied above, then the state set of  =  is = fh [15?12 i h[5 10? 13 i h[10 11? 14 i h[13 20 ? 15 ig .
DeleteTimestamptakes a history =h      iand a timestamp of typeand yields a new history = h        i .
The operation mapsinto a state set  in which all states inwhose timestampis such that
ommonpoints(   )is true, have been recomputed so that does not occur in .
For example, if = [34? and= fh[1 6?12 ig, then = fh[1 34  6?12 ig.
Note that the semantics of DeleteTimestamprelies on the denitions of
ommonpoints(and, as can be seen in [10], 1 Recall that, given a function  , its restriction to the set, denoted by , is the set of pairs   such that  and  .
 minus).InsertStatetakes a history=h      i and a stateh   i, where is of typeand  2 , and yields a new history  = h       i.
If is equal to some occurring inthen the timestampassociated with it is recomputed into a timestamp  that includes , and  = n fh    ig [ fh    ig.
If, on the other hand, does not occur in , thenis recomputed into a state set that is everywhere equal to except that every state inwhose timestamp has common points with  has been recomputed so as to make that no longer the case in  , and  =   [ fh    ig .
For example, ifh    i = h[5 8?13 iand = fh[1 6?12 ig, then = fh[1 4?12 i h[5 8?13 ig and ifh   i = h[5 8?12 iand= fh[1 6?12 ig, then  = fh[1  8?12 ig.
3.
The Monoid-Based Approach to Query Pro- cessing 3.1.
Monoids In abstract algebra, a monoidis a triple (     ) consisting of a settogether with a binary associative operation  :   ! , called the mergefunction for the monoid, and an identity element  , called the zero element of the monoid.
Note that, by denition, for all     2,(  )  =  (  ), and, for all  2 ,   =   = .
In database contexts, we take to be a database type.
Examples of monoids are ( int + 0),(int  1),(int   0), (boolean ^ true )and(boolean _ false ).
By consistent and careful naming, it is possible (and customary) to  let the merge function identify the type of the monoid, thus,  e.g., (+ 0)abbreviates(int + 0).
When, as in the examples above, is a scalar type, monoids onare called primitive monoids .
If is a collection (also commonly referred to as bulk) type, monoids on are called collection monoids and require an additional function, called the unit function for the monoid and denoted  , so that it is possible to construct all possible instances of .
An example of a collection monoid is ( set [ fg   f g), where   =  f gis the function that given anyreturns the singleton f  g.
For example, to construct the set of integers f 27 5 gone could write (  (2)  (  (7)   (5))) which gives, for =[and = f g, the set f2g [ (f 7g [ f5g) = f27 5 g.
It is customary to omit the unit function when denoting a collection monoid because its  specication is easily inferable from the merge function th at identies the monoid.
Collection monoids for s,s and  s are, therefore, written as( [ f g),(? ff gg ), and (++ [ ?), respectively, where?denotes union without duplicate removal and ++denotes list append, andf g,ff gg and[ ?denote the empty set, the empty bag and the empty list, respectively.
3.2.
Monoid Comprehensions The monoid comprehension calculus [7, 8] is now briey described.
A comprehension over the monoid is an expression of the form f j !  g, where the expressionis called the of the comprehension and !  =      ,   0, is a sequence of expressions each one of which is either a qualier of the form    or a lter in the form of a predicate over the terms in the comprehension.
In a qualier, is called the range variable and the expression  is the domain generator from which bindings forare drawn.
A well-formedness requirement (statically veriable) stipulates that if any of the generators in a monoid comprehension is over an idempotent or commutative monoid,  then the comprehension must be itself over an idempotent  or commutative monoid.
This means, e.g., that a comprehension that maps a set monoid (which is idempotent and  commutative) into a list monoid (which is neither) is ill-  formed, whereas one that maps a bag monoid into (+ 0)is well-formed, since both are commutative.
Monoid comprehensions also have a simple procedural interpretation.
For example, a monoid comprehension of the form f j      g denotes a result Rcomputed as shown in Figure 8.
Generalizing to generators gives rise tonested loops.
It is also straightforward to generalize for multiple lters.
R :=  ; forea hin : if ( ) = true then R:= (R    ( )); return R; Figure 8.
Procedural Interpretation A monoid comprehension characterizes a set of instances of the type over which it is dened.
By applying the reduc-  tions given in [7] that set can be obtained.
In this sense,  these reductions characterize a calculus.
Since, as shown  below, monoid comprehensions serve as the target of a map-  ping from OQL expressions, the monoid comprehension calculus qualies as a query calculus for object databases  and the reductions characterize a formal declarative seman - tics for OQL (thereby allowing the result of an OQL query  to be inferred).
We give some examples of OQL queries alongside their corresponding monoid comprehensions.
Figure 9 shows, in the general case, the monoid comprehension that a select-  from-where clause maps into.
The OQL query in Figure 10  returns the set of names of cities that have more than ten wards, and maps into the monoid comprehension given be-  low in the same gure.
A comprehensive description of a  mapping of OQL 1.2 into monoid comprehensions is given  OQL:sele
t from  in        in  where  Monoid comprehension: ?fj                g Figure 9.
Mapping Select?From?Where sele
t distin
t
name from
in Cities where
ount(
 wards ) 10 [f
name j
   Cities + f1jw
w ards g 10g Figure 10.
OQL to Monoid Comprehension in [13].
An algebraic optimizer over monoid comprehen-  sions is described in [8].
Our practical experience with the  monoid comprehension approach in implemented systems has been reported for parallel databases in [21] and for in-  cremental view maintenance in [1].
 4.
Extending the Monoid-Based Query Calcu- lus This section shows how the constructs in Section 2 can be incorporated into the framework described in Sec-  tion 3 to give rise to a query calculus for historical object databases.
 4.1.
Timestamps and Snapshots as Monoids Realm-based types in Tripod are implemented as primitive types with the same status as other ODMG  primitive types such as boolean,intandstring.
Since Instants andTimeIntervals are not scalar types, but set-based ones, certain aspects of their behaviour, as formalized in [11], can be captured using collection  monoids.
The assemblefunction, introduced in Section 2.1, that maps a set of values of type Instantinto a value of type Instantsis membership and cardinality preserving, and so is disassemble, its inverse.
This means that assemble ( disassemble (  )) = disassemble  ( assemble (  )), for all.
In contrast, the assemblefunction, which maps a set of values of type TimeIntervalinto a value of type TimeIntervals, coalesces, to the smallest convex (i.e., gap-free) interval containing them, any two in- tervals which either meet or overlap.
Therefore,  for some ,assemble ( disassemble (  )) 6 = disassemble  ( assemble (  )).
We can now dene collection monoids over InstantsandTimeIntervals where the zero elements are the respective empty instances  (denoted fg andfg, respectively), the unit functions are  assemble ( f  g)and assemble ( f  g), respectively, and, nally, the merge functions are the assembly  of the union of the disassembly of the arguments, i.e., union (   ) = assemble( disassemble (  ) [ disassemble  (  )) =[ andunion (   ) = assemble ( disassemble (  )[ disassemble(  )), respectively.
Both monoids inherit from the ( [ f g) monoid the properties of being idempotent and com-  mutative.
We can now write comprehensions over  the (union  fg )monoid (overInstants) and the ( union  fg )monoid (overTimeIntervals).
For these comprehensions, the lexicon for lters is extended with the  set of Boolean-valued Tripod predicates (e.g., overlap, meet) over these primitive Tripod types and the set of domain generators is extended with expressions that denote  the latter (e.g., attributes, relationships, path express ions, etc., whose domain is a Tripod temporal type, as well as Tripod operations that return instances of such types).
For example, assume the TimeIntervalsvalue  = [1 68  1012 1415 20? , then the monoid comprehension in Figure 11 counts the intervals that contain th e given Instantsliteral.
+ f1jv   unionf xjx   TI
ontains(x [9 ?) g g Figure 11.
Comprehension Over Temporal  Values  Note that coalescing is implicit in the fact that unionis dened in terms of assemble, which, as discussed above, coalesces by denition.
In summary, we have indicated how to extend the monoid comprehension calculus with two collection  monoids, one for each of the possible forms for a timestamp.
More collection monoids can, of course, be dened  over temporal Tripod types which we do not cover due to  lack of space.
Note also that although the realm-based spa-  tial types which Tripod also supports as primitive types are  not discussed in this paper, the denition of monoids (and monoid comprehensions) over them follows a similar strat-  egy as described above for realm-based temporal types.
As previously mentioned, Tripod extends the set of primitive ODMG types with realm-based temporal (and spatial)  types.
In practice, this means that application designers  have new expressive domains over which to dene attributes  and relationships and thereby model temporal (and spatial)  aspects of applications.
Section 2.2 characterized snapshots simply as values of valid types in the extended type system.
 This implies that they have associated monoids (or not) ex-  actly as described in [8], for a (non-extended) ODMG set-  ting, and above, for the realm-based temporal (and spatial)  types in the extended type system.
The monoid comprehensions that can be written are not changed.
It is histories tha t add more possibilities, as follows.
 4.2.
Histories as Monoids For the purposes of query processing, it is reasonable to assume that a history has been checked for well-formedness  (regarding granularity and type-correctness of both times - tamps and snapshots), in which case we simplify our nota-  tion and equate a history  =h      iwith its state set .
Note that, in Tripod, there is no type whose instances are histories that designers can use to model an applica-  tion (as there are, in contrast, for each of the realm-based temporal (and spatial) types).
We signal this distinction b y not using the typewriterfontwe use for the latter, and instead retain from Section 2.3 the denotation for the set of all histories (respectively, timestamps, snapshots, st ates), i.e., (respectively,,,).
We can dene collection monoids over .
For example, one where the zero element is the empty history, denoted by f h ig, the unit function is  fh  igfor any 2 , and the merge function is , as dened in Section 2.4.2.
Note that since the denition of picks the rst argument to restrict on, it follows that the corresponding monoid, (  fh ig )2 , is not commutative but it is idempotent.
As done above for Instantsand TimeIntervalsmonoids, we can write monoid comprehensions over in which the lexicon for lters stems from the set of Boolean-valued operations over histories outlin ed in Section 2.4.1, and the set of domain generators is extended by history-denoting expressions (including monoid  comprehensions other than (  fh ig )).
max f0j d   [fduration(stimestamp )js    f(t v )j( t v )   Hv  20g gg Figure 12.
Comprehension Over History For example, given the durationoperation on TimeIntervals(dened, for aTimeIntervals , as end(last()) start(first())), and a history = fh [1  6?12 i h[9  11? 14 i h[12 25? 30 ig , then the 2 Bothandare tokens (indivisible, therefore) used as left and right bracket symbols, respectively.
monoid comprehension in Figure 12 computes the longest  duration among the snapshots in that are smaller than 20, i.e., the longest period for which there are records for a value less than 20, and returns 5granules (which is the lifespan of the snapshot 12).
We have indicated how Tripod's spatial and temporal extensions to the ODMG as well as histories give rise to an extended set of monoid comprehensions.
The remainder of  this section discusses in what sense this gives rise to an ex-  tended query calculus.
Later, Section 5 shows how aggregations over historical and spatio-historical data can be e xpressed using the extended set of monoid comprehensions.
 4.3.
A Query Calculus Founded on History Monoid Comprehensions Work on the monoid approach to query calculi for object databases has yielded a wealth of results on typing,  equivalence-based rewriting and mapping into physical al-  gebras that, together, comprise as well dened a query pro-  cessing framework as relational databases have enjoyed for decades now.
By showing how timestamps and histories can  give rise to monoids and then monoid comprehensions we  have effectively indicated how one can extend an ODMG  setting with realm-based temporal (and, by analogy, spatia l) types and the notion of a history.
In [8], the core of a logical query optimizer is characterized by a set of transformations (i.e., rewriting rules) and a conuent, terminating normalization algorithm to apply  the latter.
In the usual fashion, the rewriting rules can be used to specify heuristics (e.g., push selections inside as far as they will go) that are likely to result in equivalent expre ssions which are less costly to evaluate than the original one s.
Each transformation in [8] is applicable or not depending on  the properties of the monoid in its antecedent.
Given the monoids that one can dene over the additional primitive types and over histories, the transformations dened in [8] provide us with the basic components  of a query calculus for historical object databases.
Thus, since the timestamp monoids suggested above are idempo-  tent and commutative, all six transformations in [8] that ap - ply to collection monoids apply to the timestamp monoids  as well, whereas, in contrast, for the history monoid sug-  gested above, the two such transformations that require the  argument monoid to be commutative are ruled out.
The  overall result of the approach we have described is to en-  dow Tripod, a historical object database extending ODMGcompliant ones, with a well-dened query calculus.
 5.
Examples of Queries over Temporal andSpatial Data This section shows how the query calculus for historical object databases contributed by this paper can express  queries that are representative for the class of applicatio ns that Tripod has been designed to support.
(Q1) How many elections have there ever been across all cities? + f1 j e  disassemble
